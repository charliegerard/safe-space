/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],t):t((e=e||self).tf=e.tf||{},e.tf)}(this,(function(e,t){"use strict";var a,n;!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(a||(a={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(n||(n={}));const s={};function r(e){return s[e]}function o(e,a,n,s){const r=a.inputParams[e];if(r&&void 0!==r.inputIndexStart){const e=r.inputIndexStart,o=0===r.inputIndexEnd?void 0:void 0===r.inputIndexEnd?e+1:r.inputIndexEnd;if("tensor"===r.type)return p(a.inputNames[r.inputIndexStart],n,s);if("tensors"===r.type){return a.inputNames.slice(e,o).map(e=>p(e,n,s))}const i=p(a.inputNames.slice(e)[0],n,s),m=i.dataSync();return"number"===r.type?m[0]:t.util.toNestedArray(i.shape,m)}const o=a.attrParams[e];return o&&o.value}function p(e,t,a){const[n,s]=u(e),r=a.currentContextIds.find(e=>!!t[m(n,e)]);return void 0!==r?t[m(n,r)][s]:void 0}function i(e,t){const[a,n]=u(e);return[m(a,t&&t.currentContextId),n]}function m(e,t){return t?`${e}-${t}`:e}function u(e){const t=e.split(":");return 1===t.length?[e,0]:[t[0],Number(t[t.length-1])]}function d(e,t,a){let n=o("pad",e,t,a);if("explicit"===n){n=o("explicitPaddings",e,t,a);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=n[2*e],s[e][1]=n[2*e+1];return s}return n}function c(e){return e.kept?e:t.clone(e)}var y=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var l=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var h=Object.freeze({__proto__:null,json:[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]});var f=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var N=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var g=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var x=Object.freeze({__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}]});var b=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var T=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]});var _=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var S=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var O=Object.freeze({__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]});var w=Object.freeze({__proto__:null,json:[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var A=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]});var v=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var E=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]});class D{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[y,l,h,f,N,g,x,_,T,b,S,O,w,A,v,E].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const a=e.node,n=[],s=[],r=a.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")&&n.push(e[t.name]),"Const"===t.op&&s.push(e[t.name]),e),{});let o=[];const p=[];let m={},u={};null!=t&&(m=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const d=Object.keys(r);d.forEach(e=>{const t=r[e];t.inputNames.forEach(e=>{const[a]=i(e);t.inputs.push(r[a]),r[a].children.push(t)})}),0===Object.keys(u).length?d.forEach(e=>{const t=r[e];0===t.children.length&&p.push(t)}):Object.keys(u).forEach(e=>{const[t]=i(e),a=r[t];null!=a&&(a.signatureKey=u[e],p.push(a))}),Object.keys(m).length>0?Object.keys(m).forEach(e=>{const[t]=i(e),a=r[t];a&&(a.signatureKey=m[e],o.push(a))}):o=n;let c={};return null!=e.library&&null!=e.library.function&&(c=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{})),{nodes:r,inputs:o,outputs:p,weights:s,placeholders:n,signature:t,functions:c}}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,a)=>(t[e[a].name]=a,t),{})}mapNode(e){const t=r(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.substr(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return null!=t.inputs&&(a.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(a.attrParams=t.attrs.reduce((t,a)=>{const n=a.type;let s=void 0;switch(a.type){case"string":s=V(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=V(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":s=P(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=P(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":s=k(e.attr,a.tfName,a.defaultValue||0),void 0===s&&a.tfDeprecatedName&&(s=k(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":s=j(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=j(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":s=M(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=M(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":s=q(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=q(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":s=R(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=R(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":s=B(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=B(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":s=F(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=F(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":s=L(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=L(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":s=z(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=z(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return t[a.name]={value:s,type:n},t},{})),a}mapFunction(e){const t=e.nodeDef,a=[];let n={};null!=t&&(n=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&a.push(e[t.name]),e),{}));const s=[],r=[];e.signature.inputArg.forEach(e=>{const[t]=i(e.name),a={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:C(e.type),type:"dtype"}},children:[]};a.signatureKey=e.name,s.push(a),n[t]=a}),Object.keys(n).forEach(e=>{const t=n[e];t.inputNames.forEach(e=>{const[a]=i(e);t.inputs.push(n[a]),n[a].children.push(t)})});const o=e.ret;e.signature.outputArg.forEach(e=>{const[t,a]=i(o[e.name]),s=n[t];null!=s&&(s.defaultOutput=a,r.push(s))});const p=this.mapArgsToSignature(e);return{nodes:n,inputs:s,outputs:r,weights:a,placeholders:[],signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t),{})}}mapArgToTensorInfo(e,t){let a=e.name;return null!=t&&(a=t[a]),{name:a,dtype:e.type}}}function I(e,a){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const a=t.env().global;if(void 0!==a.atob)return a.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return a?n:n.toLowerCase()}function V(e,t,a,n=!1){const s=e[t];return null!=s?I(s.s,n):a}function M(e,t,a){const n=e[t];return n?n.b:a}function k(e,t,a){const n=e[t]||{},s=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof s?s:parseInt(s,10)}function C(e){switch("string"==typeof e&&(e=a[e]),e){case a.DT_FLOAT:return"float32";case a.DT_INT32:case a.DT_INT64:case a.DT_INT8:case a.DT_UINT8:return"int32";case a.DT_BOOL:return"bool";case a.DT_DOUBLE:return"float32";case a.DT_STRING:return"string";default:return null}}function z(e,t,a){const n=e[t];return n&&n.func?n.func.name:a}function F(e,t,a){const n=e[t];return n&&n.type?C(n.type):a}function L(e,t,a){const n=e[t];return n&&n.list&&n.list.type?n.list.type.map(e=>C(e)):a}function $(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function R(e,t,a){const n=e[t];return n&&n.shape?$(n.shape):a}function j(e,t,a){const n=e[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):a}function P(e,t,a,n=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>I(e,n)):a}function B(e,t,a){const n=e[t];return n&&n.list&&n.list.shape?n.list.shape.map(e=>$(e)):a}function q(e,t,a){const n=e[t];return n&&n.list&&n.list.b?n.list.b:a}class W{constructor(e,t,a){this.node=e,this.tensorMap=t,this.context=a,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return p(e,this.tensorMap,this.context)}getAttr(e,t){const a=this.node.rawAttrs[e];if(null!=a.tensor)return p(e,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return k(this.node.rawAttrs,e,t);if(null!=a.s)return V(this.node.rawAttrs,e,t);if(null!=a.b)return M(this.node.rawAttrs,e,t);if(null!=a.shape)return R(this.node.rawAttrs,e,t);if(null!=a.type)return F(this.node.rawAttrs,e,t);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return j(this.node.rawAttrs,e,t);if(null!=a.list.s)return P(this.node.rawAttrs,e,t);if(null!=a.list.shape)return B(this.node.rawAttrs,e,t);if(null!=a.list.b)return q(this.node.rawAttrs,e,t);if(null!=a.list.type)return L(this.node.rawAttrs,e,t)}return t}}function G(e,a,n=""){t.util.assert(function(e,t){if(e.length!==t.length)return!1;for(let a=0;a<e.length;a++)if(-1!==e[a]&&-1!==t[a]&&e[a]!==t[a])return!1;return!0}(e,a),()=>n+` Shapes ${e} and ${a} must match`)}class U{constructor(e,a,n,s,r,o,p){this.name=e,this.dtype=a,this.maxSize=n,this.elementShape=s,this.identicalElementShapes=r,this.dynamicSize=o,this.clearAfterRead=p,this.tensors=[],this.closed_=!1,this.idTensor=t.scalar(0),t.keep(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(){this.tensors.forEach(e=>e.tensor.dispose()),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,a){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(a.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${a.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=a.shape),G(this.elementShape,a.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=a,t.keep(a),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,a)=>this.write(e,t[a]))}gather(e,a){if(a&&a!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${a}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return t.tensor([],[0].concat(this.elementShape));const n=this.readMany(e);return G(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),t.stack(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return t.tensor([],[0].concat(this.elementShape));const a=[];for(let e=0;e<this.size();e++)a.push(e);const n=this.readMany(a);return G(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),t.concat(n,0)}scatter(e,a){if(a.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${a.dtype}`);if(e.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${a.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,t.unstack(a,0))}split(e,a){if(a.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${a.dtype}`);let n=0;const s=e.map(e=>(n+=e,n));if(n!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${a.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const r=0===n?0:a.size/n,o=[];t.tidy(()=>{a=a.reshape([1,n,r]);for(let n=0;n<e.length;++n){const p=[0,0===n?0:s[n-1],0],i=[1,e[n],r];o[n]=t.slice(a,p,i).reshape(this.elementShape)}return o});const p=[];for(let t=0;t<e.length;t++)p[t]=t;this.writeMany(p,o)}}class H{constructor(e,a,n,s=-1){this.tensors=e,this.elementShape=a,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);G(a,e.shape,"TensorList shape mismatch: "),t.keep(e)}),this.idTensor=t.scalar(0),this.maxNumElements=s,t.keep(this.idTensor)}get id(){return this.idTensor.id}copy(){return new H([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(){this.tensors.forEach(e=>e.dispose()),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,a,n=-1){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);return G(e,this.elementShape,"TensorList shape mismatch: "),t.tidy(()=>{const a=this.tensors.map(t=>t.reshape(e));return t.stack(a,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const a=this.tensors.pop();return G(a.shape,e,"TensorList shape mismatch: "),a.reshape(e)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(G(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");t.keep(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+e);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);return G(this.tensors[e].shape,t,"TensorList shape mismatch: "),this.tensors[e]}setItem(e,a){if(a.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);G(this.elementShape,a.shape,"TensorList shape mismatch: "),t.keep(a),this.tensors[e]=a}gather(e,a,n){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);return G(this.elementShape,n,"TensorList shape mismatch: "),0===(e=e.slice(0,this.size())).length?t.tensor([],[0].concat(this.elementShape)):t.tidy(()=>{const a=e.map(e=>this.tensors[e].reshape(n));return t.stack(a,0)})}concat(e,a){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);return G(this.elementShape,a,"TensorList shape mismatch: "),0===this.size()?t.tensor([],[0].concat(this.elementShape)):t.tidy(()=>{const e=this.tensors.map(e=>e.reshape(a));return t.concat(e,0)})}}const Q=async(e,a,n)=>{switch(e.op){case"If":case"StatelessIf":{const t=o("thenBranch",e,a,n),s=o("elseBranch",e,a,n),r=o("cond",e,a,n),p=o("args",e,a,n);return(await r.data())[0]?n.functionMap[t].executeFunctionAsync(p,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(p,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const t=o("body",e,a,n),s=o("cond",e,a,n),r=o("args",e,a,n),p=await n.functionMap[s].executeFunctionAsync(r,n.tensorArrayMap,n.tensorListMap),i=r.map(e=>e.id);let m=await p[0].data();p.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()});let u=r;for(;m[0];){const e=u;u=await n.functionMap[t].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const a=u.map(e=>e.id);e.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||-1!==a.indexOf(e.id)||e.dispose()});const r=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);m=await r[0].data(),r.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||-1!==a.indexOf(e.id)||e.dispose()})}return u}case"LoopCond":return[c(o("pred",e,a,n))];case"Switch":{const t=o("pred",e,a,n);let s=o("data",e,a,n);return s.kept||(s=c(s)),(await t.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const t=e.inputNames.find(e=>void 0!==p(e,a,n));if(t){return[c(p(t,a,n))]}return}case"Enter":{const t=o("frameName",e,a,n),s=o("tensor",e,a,n);return n.enterFrame(t),[c(s)]}case"Exit":{const t=o("tensor",e,a,n);return n.exitFrame(),[c(t)]}case"NextIteration":{const t=o("tensor",e,a,n);return n.nextIteration(),[c(t)]}case"TensorArrayV3":{const s=o("size",e,a,n),r=o("dtype",e,a,n),p=o("elementShape",e,a,n),i=o("dynamicSize",e,a,n),m=o("clearAfterRead",e,a,n),u=o("identicalElementShapes",e,a,n),d=o("name",e,a,n),c=new U(d,r,s,p,u,i,m);return n.addTensorArray(c),[c.idTensor,t.scalar(1)]}case"TensorArrayWriteV3":{const t=o("tensorArrayId",e,a,n),s=o("index",e,a,n),r=o("tensor",e,a,n),p=n.getTensorArray(t.id);return p.write(s,r),[p.idTensor]}case"TensorArrayReadV3":{const t=o("tensorArrayId",e,a,n),s=o("index",e,a,n);return[n.getTensorArray(t.id).read(s)]}case"TensorArrayGatherV3":{const t=o("tensorArrayId",e,a,n),s=o("indices",e,a,n),r=o("dtype",e,a,n);return[n.getTensorArray(t.id).gather(s,r)]}case"TensorArrayScatterV3":{const t=o("tensorArrayId",e,a,n),s=o("indices",e,a,n),r=o("tensor",e,a,n),p=n.getTensorArray(t.id);return p.scatter(s,r),[p.idTensor]}case"TensorArrayConcatV3":{const t=o("tensorArrayId",e,a,n),s=n.getTensorArray(t.id),r=o("dtype",e,a,n);return[s.concat(r)]}case"TensorArraySplitV3":{const t=o("tensorArrayId",e,a,n),s=o("tensor",e,a,n),r=o("lengths",e,a,n),p=n.getTensorArray(t.id);return p.split(r,s),[p.idTensor]}case"TensorArraySizeV3":{const s=o("tensorArrayId",e,a,n),r=n.getTensorArray(s.id);return[t.scalar(r.size(),"int32")]}case"TensorArrayCloseV3":{const t=o("tensorArrayId",e,a,n),s=n.getTensorArray(t.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const t=o("tensorListId",e,a,n),s=o("index",e,a,n),r=o("tensor",e,a,n),p=n.getTensorList(t.id);return p.setItem(s,r),[p.idTensor]}case"TensorListGetItem":{const t=o("tensorListId",e,a,n),s=o("index",e,a,n),r=o("elementShape",e,a,n),p=o("elementDType",e,a,n);return[n.getTensorList(t.id).getItem(s,r,p)]}case"TensorListScatterV2":case"TensorListScatter":{const s=o("indices",e,a,n),r=function(e,a,n,s){if(a.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${a.length} vs. ${e.shape[0]}`);const r=Math.max(...a);if(null!=s&&-1!==s&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new H([],n,e.dtype,s),p=t.unstack(e,0);return a.forEach((e,t)=>{o.setItem(e,p[t])}),o}(o("tensor",e,a,n),s,o("elementShape",e,a,n),o("numElements",e,a,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":{const t=function(e,t,a){return new H([],e,t,a)}(o("elementShape",e,a,n),o("elementDType",e,a,n),o("numElements",e,a,n));return n.addTensorList(t),[t.idTensor]}case"TensorListGather":{const t=o("tensorListId",e,a,n),s=o("indices",e,a,n),r=o("elementShape",e,a,n),p=o("elementDType",e,a,n);return[n.getTensorList(t.id).gather(s,p,r)]}case"TensorListStack":{const t=o("tensorListId",e,a,n),s=o("elementShape",e,a,n),r=o("elementDType",e,a,n),p=o("numElements",e,a,n);return[n.getTensorList(t.id).stack(s,r,p)]}case"TensorListFromTensor":{const t=function(e,t,a){const n=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+e.shape);if(e.dtype!==a)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${a}`);G(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=e.unstack();return new H(s,t,n)}(o("tensor",e,a,n),o("elementShape",e,a,n),o("elementDType",e,a,n));return n.addTensorList(t),[t.idTensor]}case"TensorListConcat":{const t=o("tensorListId",e,a,n),s=n.getTensorList(t.id),r=o("dtype",e,a,n),p=o("elementShape",e,a,n);return[s.concat(r,p)]}case"TensorListPushBack":{const t=o("tensorListId",e,a,n),s=o("tensor",e,a,n),r=n.getTensorList(t.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const t=o("tensorListId",e,a,n),s=o("elementShape",e,a,n),r=o("elementDType",e,a,n);return[n.getTensorList(t.id).popBack(s,r)]}case"TensorListSplit":{const s=o("tensor",e,a,n),r=o("elementShape",e,a,n),p=function(e,a,n){let s=0;const r=a.map(e=>(s+=e,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${e.shape}`);const o=0===s?0:e.size/s,p=t.tidy(()=>{const p=[];e=e.reshape([1,s,o]);for(let s=0;s<a.length;++s){const i=[0,0===s?0:r[s-1],0],m=[1,a[s],o];p[s]=t.slice(e,i,m).reshape(n)}return e.dispose(),p}),i=new H([],n,e.dtype,a.length);for(let e=0;e<p.length;e++)i.setItem(e,p[e]);return i}(s,o("lengths",e,a,n),r);return n.addTensorList(p),[p.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function K(e,t,a){const[n,s]=o("fusedOps",e,t,a),r="biasadd"===n,p="prelu"===s,i="fusedbatchnorm"===n,m=o("numArgs",e,t,a);if(r){if(p&&2!==m)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!p&&1!==m)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const u=o("strides",e,t,a),c=d(e,t,a),y=o("dataFormat",e,t,a).toUpperCase(),l=o("dilations",e,t,a),[h,f]=o("args",e,t,a);return{stride:u,pad:c,dataFormat:y,dilations:l,biasArg:h,preluArg:f,activationFunc:s}}function X(e,t,a){return{boxes:o("boxes",e,t,a),scores:o("scores",e,t,a),maxOutputSize:o("maxOutputSize",e,t,a),iouThreshold:o("iouThreshold",e,t,a),scoreThreshold:o("scoreThreshold",e,t,a),softNmsSigma:o("softNmsSigma",e,t,a)}}function Z(e,a,n){const s=((e,a,n)=>{switch(e.category){case"arithmetic":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[t.add(o("a",e,a,n),o("b",e,a,n))];case"AddN":return[t.addN(o("tensors",e,a,n))];case"FloorMod":case"Mod":return[t.mod(o("a",e,a,n),o("b",e,a,n))];case"Mul":return[t.mul(o("a",e,a,n),o("b",e,a,n))];case"RealDiv":case"Div":return[t.div(o("a",e,a,n),o("b",e,a,n))];case"DivNoNan":return[t.divNoNan(o("a",e,a,n),o("b",e,a,n))];case"FloorDiv":return[t.floorDiv(o("a",e,a,n),o("b",e,a,n))];case"Sub":return[t.sub(o("a",e,a,n),o("b",e,a,n))];case"Minimum":return[t.minimum(o("a",e,a,n),o("b",e,a,n))];case"Maximum":return[t.maximum(o("a",e,a,n),o("b",e,a,n))];case"Pow":return[t.pow(o("a",e,a,n),o("b",e,a,n))];case"SquaredDifference":return[t.squaredDifference(o("a",e,a,n),o("b",e,a,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"basic_math":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[t.abs(o("x",e,a,n))];case"Acos":return[t.acos(o("x",e,a,n))];case"Acosh":return[t.acosh(o("x",e,a,n))];case"Asin":return[t.asin(o("x",e,a,n))];case"Asinh":return[t.asinh(o("x",e,a,n))];case"Atan":return[t.atan(o("x",e,a,n))];case"Atan2":return[t.atan2(o("x",e,a,n),o("y",e,a,n))];case"Atanh":return[t.atanh(o("x",e,a,n))];case"Ceil":return[t.ceil(o("x",e,a,n))];case"Complex":return[t.complex(o("real",e,a,n),o("imag",e,a,n))];case"Cos":return[t.cos(o("x",e,a,n))];case"Cosh":return[t.cosh(o("x",e,a,n))];case"Elu":return[t.elu(o("x",e,a,n))];case"Erf":return[t.erf(o("x",e,a,n))];case"Exp":return[t.exp(o("x",e,a,n))];case"Expm1":return[t.expm1(o("x",e,a,n))];case"Floor":return[t.floor(o("x",e,a,n))];case"Log":return[t.log(o("x",e,a,n))];case"Log1p":return[t.log1p(o("x",e,a,n))];case"Imag":return[t.imag(o("x",e,a,n))];case"Neg":return[t.neg(o("x",e,a,n))];case"Reciprocal":return[t.reciprocal(o("x",e,a,n))];case"Real":return[t.real(o("x",e,a,n))];case"Relu":return[t.relu(o("x",e,a,n))];case"Round":return[t.round(o("x",e,a,n))];case"Selu":return[t.selu(o("x",e,a,n))];case"Sigmoid":return[t.sigmoid(o("x",e,a,n))];case"Sin":return[t.sin(o("x",e,a,n))];case"Sign":return[t.sign(o("x",e,a,n))];case"Sinh":return[t.sinh(o("x",e,a,n))];case"Softplus":return[t.softplus(o("x",e,a,n))];case"Sqrt":return[t.sqrt(o("x",e,a,n))];case"Square":return[t.square(o("x",e,a,n))];case"Tanh":return[t.tanh(o("x",e,a,n))];case"Tan":return[t.tan(o("x",e,a,n))];case"Relu6":case"ClipByValue":return[t.clipByValue(o("x",e,a,n),o("clipValueMin",e,a,n),o("clipValueMax",e,a,n))];case"Rsqrt":return[t.rsqrt(p(e.inputNames[0],a,n))];case"Prod":return[t.prod(o("x",e,a,n),o("axes",e,a,n))];case"LeakyRelu":return[t.leakyRelu(o("x",e,a,n),o("alpha",e,a,n))];case"Prelu":return[t.prelu(o("x",e,a,n),o("alpha",e,a,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"control":return Q(e,a,n);case"convolution":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"Conv1D":{const s=o("stride",e,a,n),r=o("pad",e,a,n),p=o("dataFormat",e,a,n).toUpperCase(),i=o("dilation",e,a,n);return[t.conv1d(o("x",e,a,n),o("filter",e,a,n),s,r,p,i)]}case"Conv2D":{const s=o("strides",e,a,n),r=d(e,a,n),p=o("dataFormat",e,a,n).toUpperCase(),i=o("dilations",e,a,n);return[t.conv2d(o("x",e,a,n),o("filter",e,a,n),[s[1],s[2]],r,p,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:s,pad:r,dataFormat:p,dilations:i,biasArg:m,preluArg:u,activationFunc:d}=K(e,a,n);return[t.fused.conv2d({x:o("x",e,a,n),filter:o("filter",e,a,n),strides:[s[1],s[2]],pad:r,dataFormat:p,dilations:[i[1],i[2]],bias:m,activation:d,preluActivationWeights:u})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:r,dataFormat:p,dilations:i,biasArg:m,preluArg:u,activationFunc:d}=K(e,a,n);return[t.fused.depthwiseConv2d({x:o("x",e,a,n),filter:o("filter",e,a,n),strides:[s[1],s[2]],pad:r,dataFormat:p,dilations:[i[1],i[2]],bias:m,activation:d,preluActivationWeights:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=o("outputShape",e,a,n),r=o("strides",e,a,n),p=d(e,a,n);return[t.conv2dTranspose(o("x",e,a,n),o("filter",e,a,n),s,[r[1],r[2]],p)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=o("strides",e,a,n),r=d(e,a,n),p=o("dilations",e,a,n),i=o("dataFormat",e,a,n).toUpperCase();return[t.depthwiseConv2d(o("input",e,a,n),o("filter",e,a,n),[s[1],s[2]],r,i,[p[1],p[2]])]}case"Conv3D":{const s=o("strides",e,a,n),r=o("pad",e,a,n),p=o("dataFormat",e,a,n).toUpperCase(),i=o("dilations",e,a,n);return[t.conv3d(o("x",e,a,n),o("filter",e,a,n),[s[1],s[2],s[3]],r,p,[i[1],i[2],i[3]])]}case"AvgPool":{const s=o("strides",e,a,n),r=o("pad",e,a,n),p=o("kernelSize",e,a,n);return[t.avgPool(o("x",e,a,n),[p[1],p[2]],[s[1],s[2]],r)]}case"MaxPool":{const s=o("strides",e,a,n),r=o("pad",e,a,n),p=o("kernelSize",e,a,n);return[t.maxPool(o("x",e,a,n),[p[1],p[2]],[s[1],s[2]],r)]}case"MaxPoolWithArgmax":{const s=o("strides",e,a,n),r=o("pad",e,a,n),p=o("kernelSize",e,a,n),i=o("includeBatchInIndex",e,a,n),{result:m,indexes:u}=t.maxPoolWithArgmax(o("x",e,a,n),[p[1],p[2]],[s[1],s[2]],r,i);return[m,u]}case"AvgPool3D":{const s=o("strides",e,a,n),r=o("pad",e,a,n),p=o("kernelSize",e,a,n);return[t.avgPool3d(o("x",e,a,n),[p[1],p[2],p[3]],[s[1],s[2],s[3]],r)]}case"MaxPool3D":{const s=o("strides",e,a,n),r=o("pad",e,a,n),p=o("kernelSize",e,a,n);return[t.maxPool3d(o("x",e,a,n),[p[1],p[2],p[3]],[s[1],s[2],s[3]],r)]}case"Dilation2D":{const s=o("strides",e,a,n),r=o("pad",e,a,n),p=o("dilations",e,a,n),i=s[1],m=s[2],u=p[1],d=p[2];return[t.dilation2d(o("x",e,a,n),o("filter",e,a,n),[i,m],r,[u,d],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"creation":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"Fill":{const s=o("shape",e,a,n),r=o("dtype",e,a,n),p=o("value",e,a,n);return[t.fill(s,p,r)]}case"LinSpace":{const s=o("start",e,a,n),r=o("stop",e,a,n),p=o("num",e,a,n);return[t.linspace(s,r,p)]}case"Multinomial":{const s=o("logits",e,a,n),r=o("numSamples",e,a,n),p=o("seed",e,a,n);return[t.multinomial(s,r,p)]}case"OneHot":{const s=o("indices",e,a,n),r=o("depth",e,a,n),p=o("onValue",e,a,n),i=o("offValue",e,a,n);return[t.oneHot(s,r,p,i)]}case"Ones":return[t.ones(o("shape",e,a,n),o("dtype",e,a,n))];case"OnesLike":return[t.onesLike(o("x",e,a,n))];case"RandomUniform":return[t.randomUniform(o("shape",e,a,n),o("minval",e,a,n),o("maxval",e,a,n),o("dtype",e,a,n))];case"Range":{const s=o("start",e,a,n),r=o("stop",e,a,n),p=o("step",e,a,n);return[t.range(s,r,p,o("dtype",e,a,n))]}case"TruncatedNormal":{const s=o("shape",e,a,n),r=o("mean",e,a,n),p=o("stdDev",e,a,n),i=o("seed",e,a,n);return[t.truncatedNormal(s,r,p,o("dtype",e,a,n),i)]}case"Zeros":return[t.zeros(o("shape",e,a,n),o("dtype",e,a,n))];case"ZerosLike":return[t.zerosLike(o("x",e,a,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"dynamic":return(async(e,a,n)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:r,maxOutputSize:o,iouThreshold:p,scoreThreshold:i,softNmsSigma:m}=X(e,a,n),u=await t.image.nonMaxSuppressionWithScoreAsync(s,r,o,p,i,m);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:r,maxOutputSize:p,iouThreshold:i,scoreThreshold:m}=X(e,a,n),u=o("padToMaxOutputSize",e,a,n),d=await t.image.nonMaxSuppressionPaddedAsync(s,r,p,i,m,u);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:r,maxOutputSize:o,iouThreshold:p,scoreThreshold:i}=X(e,a,n);return[await t.image.nonMaxSuppressionAsync(s,r,o,p,i)]}case"Where":{const s=o("condition",e,a,n).asType("bool"),r=[await t.whereAsync(s)];return s.dispose(),r}case"ListDiff":return t.setdiff1dAsync(o("x",e,a,n),o("y",e,a,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n);case"evaluation":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"TopKV2":{const s=o("x",e,a,n),r=o("k",e,a,n),p=o("sorted",e,a,n),i=t.topk(s,r,p);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"image":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"ResizeBilinear":{const s=o("images",e,a,n),r=o("size",e,a,n),p=o("alignCorners",e,a,n);return[t.image.resizeBilinear(s,[r[0],r[1]],p)]}case"ResizeNearestNeighbor":{const s=o("images",e,a,n),r=o("size",e,a,n),p=o("alignCorners",e,a,n);return[t.image.resizeNearestNeighbor(s,[r[0],r[1]],p)]}case"CropAndResize":{const s=o("image",e,a,n),r=o("boxes",e,a,n),p=o("boxInd",e,a,n),i=o("cropSize",e,a,n),m=o("method",e,a,n),u=o("extrapolationValue",e,a,n);return[t.image.cropAndResize(s,r,p,i,m,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"graph":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"Const":return a[e.name];case"PlaceholderWithDefault":const s=o("default",e,a,n);return[p(e.name,a,n)||s];case"Placeholder":return[p(e.name,a,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[c(o("x",e,a,n))];case"IdentityN":return o("x",e,a,n).map(e=>c(e));case"Snapshot":return[c(o("x",e,a,n))];case"Shape":return[t.tensor1d(o("x",e,a,n).shape,"int32")];case"ShapeN":return o("x",e,a,n).map(e=>t.tensor1d(e.shape));case"Size":return[t.scalar(o("x",e,a,n).size,"int32")];case"Rank":return[t.scalar(o("x",e,a,n).rank,"int32")];case"NoOp":return[t.scalar(1)];case"Print":const r=o("x",e,a,n),i=o("data",e,a,n),m=o("message",e,a,n),u=o("summarize",e,a,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(m);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,u));return[r];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"logical":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"Equal":return[t.equal(o("a",e,a,n),o("b",e,a,n))];case"NotEqual":return[t.notEqual(o("a",e,a,n),o("b",e,a,n))];case"Greater":return[t.greater(o("a",e,a,n),o("b",e,a,n))];case"GreaterEqual":return[t.greaterEqual(o("a",e,a,n),o("b",e,a,n))];case"Less":return[t.less(o("a",e,a,n),o("b",e,a,n))];case"LessEqual":return[t.lessEqual(o("a",e,a,n),o("b",e,a,n))];case"LogicalAnd":return[t.logicalAnd(o("a",e,a,n),o("b",e,a,n))];case"LogicalNot":return[t.logicalNot(o("a",e,a,n))];case"LogicalOr":return[t.logicalOr(o("a",e,a,n),o("b",e,a,n))];case"Select":case"SelectV2":return[t.where(o("condition",e,a,n),o("a",e,a,n),o("b",e,a,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"matrices":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[t.matMul(o("a",e,a,n),o("b",e,a,n),o("transposeA",e,a,n),o("transposeB",e,a,n))];case"Transpose":return[t.transpose(o("x",e,a,n),o("perm",e,a,n))];case"_FusedMatMul":const[s,r]=o("fusedOps",e,a,n),p="biasadd"===s,i="prelu"===r,m=o("numArgs",e,a,n);if(p){if(i&&2!==m)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==m)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=o("args",e,a,n);return[t.fused.matMul({a:o("a",e,a,n),b:o("b",e,a,n),transposeA:o("transposeA",e,a,n),transposeB:o("transposeB",e,a,n),bias:u,activation:r,preluActivationWeights:d})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"normalization":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[t.batchNorm(o("x",e,a,n),o("mean",e,a,n),o("variance",e,a,n),o("offset",e,a,n),o("scale",e,a,n),o("epsilon",e,a,n))];case"LRN":return[t.localResponseNormalization(o("x",e,a,n),o("radius",e,a,n),o("bias",e,a,n),o("alpha",e,a,n),o("beta",e,a,n))];case"Softmax":return[t.softmax(o("x",e,a,n))];case"LogSoftmax":return[t.logSoftmax(o("x",e,a,n))];case"SparseToDense":return[t.sparseToDense(o("sparseIndices",e,a,n),o("outputShape",e,a,n),o("sparseValues",e,a,n),o("defaultValue",e,a,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"reduction":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"Max":{const s=o("axis",e,a,n),r=o("keepDims",e,a,n);return[t.max(o("x",e,a,n),s,r)]}case"Mean":{const s=o("axis",e,a,n),r=o("keepDims",e,a,n);return[t.mean(o("x",e,a,n),s,r)]}case"Min":{const s=o("axis",e,a,n),r=o("keepDims",e,a,n);return[t.min(o("x",e,a,n),s,r)]}case"Sum":{const s=o("axis",e,a,n),r=o("keepDims",e,a,n);return[t.sum(o("x",e,a,n),s,r)]}case"All":{const s=o("axis",e,a,n),r=o("keepDims",e,a,n);return[t.all(o("x",e,a,n),s,r)]}case"Any":{const s=o("axis",e,a,n),r=o("keepDims",e,a,n);return[t.any(o("x",e,a,n),s,r)]}case"ArgMax":{const s=o("axis",e,a,n);return[t.argMax(o("x",e,a,n),s)]}case"ArgMin":{const s=o("axis",e,a,n);return[t.argMin(o("x",e,a,n),s)]}case"Prod":{const s=o("axis",e,a,n),r=o("keepDims",e,a,n);return[t.prod(o("x",e,a,n),s,r)]}case"Cumsum":{const s=o("axis",e,a,n),r=o("exclusive",e,a,n),p=o("reverse",e,a,n);return[t.cumsum(o("x",e,a,n),s,r,p)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"slice_join":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=o("n",e,a,n),r=o("axis",e,a,n);let p=o("tensors",e,a,n);return p=p.slice(0,s),[t.concat(p,r)]}case"GatherV2":case"Gather":{const s=o("axis",e,a,n),r=o("x",e,a,n),p=o("indices",e,a,n);return[t.gather(r,p.asType("int32"),s)]}case"ReverseV2":case"Reverse":{const s=o("axis",e,a,n),r=o("x",e,a,n);return[t.reverse(r,s)]}case"Slice":{const s=o("begin",e,a,n),r=o("size",e,a,n);return[t.slice(o("x",e,a,n),s,r)]}case"StridedSlice":{const s=o("begin",e,a,n),r=o("end",e,a,n),p=o("strides",e,a,n),i=o("beginMask",e,a,n),m=o("endMask",e,a,n),u=o("ellipsisMask",e,a,n),d=o("newAxisMask",e,a,n),c=o("shrinkAxisMask",e,a,n),y=o("x",e,a,n);return[t.stridedSlice(y,s,r,p,i,m,u,d,c)]}case"Pack":return t.tidy(()=>{const s=o("axis",e,a,n),r=o("tensors",e,a,n),p=r[0].shape,i=r[0].squeeze().shape,m=r.map(e=>{const a=t.util.arraysEqual(e.shape,p);if(!a&&!t.util.arraysEqual(e.squeeze().shape,i))throw new Error("the input tensors shape does not match");return a?e:e.reshape(p)});return[t.stack(m,s)]});case"Unpack":{const s=o("axis",e,a,n),r=o("tensor",e,a,n);return t.unstack(r,s)}case"Tile":{const s=o("reps",e,a,n);return[t.tile(o("x",e,a,n),s)]}case"Split":case"SplitV":{const s=o("axis",e,a,n),r=o("numOrSizeSplits",e,a,n),p=o("x",e,a,n);return t.split(p,r,s)}case"ScatterNd":{const s=o("indices",e,a,n),r=o("values",e,a,n),p=o("shape",e,a,n);return[t.scatterND(s,r,p)]}case"GatherNd":{const s=o("x",e,a,n),r=o("indices",e,a,n);return[t.gatherND(s,r)]}case"SparseToDense":{const s=o("sparseIndices",e,a,n),r=o("outputShape",e,a,n),p=o("sparseValues",e,a,n),i=o("defaultValue",e,a,n);return[t.sparseToDense(s,p,r,p.dtype===i.dtype?i:i.asType(p.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"spectral":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"FFT":return[t.fft(o("x",e,a,n))];case"IFFT":return[t.ifft(o("x",e,a,n))];case"RFFT":return[t.rfft(o("x",e,a,n))];case"IRFFT":return[t.irfft(o("x",e,a,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"transformation":return t.tidy(()=>((e,a,n)=>{switch(e.op){case"Cast":return[t.cast(o("x",e,a,n),o("dtype",e,a,n))];case"ExpandDims":{const s=o("axis",e,a,n);return[t.expandDims(o("x",e,a,n),s)]}case"Squeeze":{const s=o("axis",e,a,n);return[t.squeeze(o("x",e,a,n),s)]}case"Reshape":return[t.reshape(o("x",e,a,n),o("shape",e,a,n))];case"PadV2":case"Pad":return[t.pad(o("x",e,a,n),o("padding",e,a,n),o("constantValue",e,a,n))];case"SpaceToBatchND":{const s=o("blockShape",e,a,n),r=o("paddings",e,a,n);return[t.spaceToBatchND(o("x",e,a,n),s,r)]}case"BatchToSpaceND":{const s=o("blockShape",e,a,n),r=o("crops",e,a,n);return[t.batchToSpaceND(o("x",e,a,n),s,r)]}case"DepthToSpace":{const s=o("blockSize",e,a,n),r=o("dataFormat",e,a,n).toUpperCase();return[t.depthToSpace(o("x",e,a,n),s,r)]}case"BroadcastTo":return[t.broadcastTo(o("x",e,a,n),o("shape",e,a,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,a,n));case"custom":const s=r(e.op);if(s&&s.customExecutor)return s.customExecutor(new W(e,a,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,a,n);return s instanceof Promise?s.then(e=>[].concat(e)):[].concat(s)}class Y{constructor(e={},t={},a={},n={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=a,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose();for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose()}}function J(e,t,a){const n=new Set,s=[];let r=null,o=null;const p=new Set,i=Object.keys(e).map(e=>u(e)[0]),m=[...t];for(;m.length>0;){const e=m.pop();(ae(e)||ne(e))&&null==r&&(r=e,o=r.children.map(e=>e.name).filter(e=>n.has(e))),n.add(e.name),null==a[e.name]&&(-1===i.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach(e=>{p.has(e.name)||(p.add(e.name),m.push(e))}):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:n,missingInputs:s,dynamicNode:r,syncInputs:o}}const ee=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],te=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];function ae(e){return ee.indexOf(e.op)>=0}function ne(e){return te.indexOf(e.op)>=0}class se{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new se(e.functions[t],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const a=e.map(e=>e.name).sort(),n=t.map(e=>e.name).sort();return a.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(e,t){const a=J(e,t,this.weightMap),{missingInputs:n,dynamicNode:s,syncInputs:r}=a;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(n.length>0){const a=t.map(e=>e.name),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${s}]. Missing the following inputs: [${n}]`)}return function(e,t,a){const{usedNodes:n,inputs:s}=a,r=[];Object.keys(s).map(e=>u(e)[0]).map(t=>e.nodes[t]).forEach(e=>{n.has(e.name)&&r.push(e)}),e.weights.forEach(e=>{n.has(e.name)&&r.push(e)});const o=new Set,p=[];for(;r.length>0;){const e=r.pop();o.add(e.name),t[e.name]||p.push(e),e.children.forEach(e=>{!o.has(e.name)&&n.has(e.name)&&e.inputs.every(e=>o.has(e.name))&&r.push(e)})}return p}(this.graph,this.weightMap,a)}execute(e,a){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),a=this.mapOutputs(a),this.checkOutputs(a);const s=n.map(e=>this.graph.nodes[u(e)[0]]),r=a.map(e=>this.graph.nodes[u(e)[0]]),o=this.getCompilationKey(s,r);let i=this.compiledMap.get(o);null==i&&(i=this.compile(e,r),this.compiledMap.set(o,i));const m={},d={};return t.tidy(()=>{const t=new Y(this.weightMap,m,d,this.functionExecutorMap),n=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[a,s]=u(t),r=[];r[s]=e[t],n[a]=r});const s=this.getFrozenTensorIds(n),r={};for(let e=0;e<i.length;e++){const o=i[e];if(!n[o.name]){const e=Z(o,n,t);if(e instanceof Promise)throw new Error(`The execution of the op '${o.op}' returned a promise. Please use model.executeAsync() instead.`);n[o.name]=e,this.checkTensorForDisposal(o.name,o,n,t,s,a,r)}}return null==this.parent&&t.dispose(),a.map(e=>p(e,n,t))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,a,n,s,r,o){"control"!==t.category&&-1===r.indexOf(e)&&(a[e].forEach(e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)}),t.inputs.forEach(e=>{if("control"!==e.category){const t=function(e,t,a){return t[m(e,a.currentContextId)]}(e.name,a,n);null!=t&&t.forEach(e=>{if(e&&!s.has(e.id)){const t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,a=!1,n={},s={}){a||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const r=new Y(this.weightMap,n,s,this.functionExecutorMap),o=await this.executeWithControlFlow(e,r,t,a),i=t.map(e=>p(e,o,r)),m=new Set(i.map(e=>e.id)),u=new Set(Object.keys(e).map(t=>e[t].id));return Object.keys(o).forEach(e=>{o[e].forEach(e=>{!e||e.isDisposed||m.has(e.id)||u.has(e.id)||-1!==this.weightIds.indexOf(e.id)||e.dispose()})}),null==this.parent&&r.dispose(),i}async executeFunctionAsync(e,t,a){const n=e.reduce((e,t,a)=>(e[this.inputs[a].name]=t,e),{});return this._executeAsync(n,this.outputNodes,!0,t,a)}async executeWithControlFlow(e,t,a,n){const s=Object.keys(e),r=s.map(e=>this.graph.nodes[u(e)[0]]),o=a.map(e=>this.graph.nodes[u(e)[0]]),{usedNodes:i,missingInputs:m,dynamicNode:d,syncInputs:c}=J(e,o,this.weightMap),y=[...r,...this.graph.weights].map(e=>({node:e,contexts:t.currentContext})),l=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[a,n]=u(t),s=[];s[n]=e[t],l[a]=s});const h={},f=this.getFrozenTensorIds(l),N={};for(;y.length>0;){const e=this.processStack(r,y,t,l,N,f,a,h,i);await Promise.all(e)}null!=d||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const g=o.filter(e=>!ae(e)&&!p(e.name,l,t)).map(e=>e.name);if(g.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${c}]`),new Error(`Cannot compute the outputs [${g}] from the provided inputs [${s}]. Consider providing the following inputs: [${m}]. ${e}`)}return l}processStack(e,t,a,n,s,r,p,m,u){const d=[];for(;t.length>0;){const c=t.pop();a.currentContext=c.contexts;let y="";if("Enter"===c.node.op&&o("isConstant",c.node,n,a)&&([y]=i(c.node.name,a)),-1===e.indexOf(c.node)){const e=Z(c.node,n,a);y||([y]=i(c.node.name,a));const o=a.currentContext;e instanceof Promise?d.push(e.then(e=>(n[y]=e,a.currentContext=o,this.checkTensorForDisposal(y,c.node,n,a,r,p,m),this.processChildNodes(c.node,t,a,n,s,u),e))):(n[y]=e,this.checkTensorForDisposal(y,c.node,n,a,r,p,m),this.processChildNodes(c.node,t,a,n,s,u))}else this.processChildNodes(c.node,t,a,n,s,u)}return d}processChildNodes(e,t,a,n,s,r){e.children.forEach(e=>{const[o]=i(e.name,a);!s[o]&&r.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!p(e,n,a))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every(e=>!!p(e,n,a))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(a=>{const n=e[a],[s]=u(a),r=this.graph.nodes[s];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value,a=e.length===n.shape.length&&n.shape.every((t,a)=>-1===e[a]||e[a]===t);t.util.assert(a,()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&t.util.assert(n.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){const t={};for(const a in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]){t[this._signature.inputs[a].name]=e[a]}else t[a]=e[a];return t}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=u(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e},{})}checkOutputs(e){e.forEach(e=>{const[t]=u(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)})}}class re{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={})}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=t.io.browserHTTPRequest(e,this.loadOptions);else{const a=t.io.getLoadHandlers(e,this.loadOptions);if(0===a.length)a.push(t.io.browserHTTPRequest(e,this.loadOptions));else if(a.length>1)throw new Error(`Found more than one (${a.length}) load handlers for URL '${[e]}'`);this.handler=a[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const a=this.artifacts.modelTopology;let n={};null!=this.artifacts.userDefinedMetadata&&(n=this.artifacts.userDefinedMetadata.signature),this.version=`${a.versions.producer}.${a.versions.minConsumer}`;const s=t.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);return this.executor=new se(D.Instance.transformGraph(a,n)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),!0}async save(e,a){if("string"==typeof e){const a=t.io.getSaveHandlers(e);if(0===a.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(a.length>1)throw new Error(`Found more than one (${a.length}) save handlers for URL '${e}'`);e=a[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof t.Tensor||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,a,n)=>(t[a]=e[n],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=this.executor.execute(e,t);return a.length>1?a:a[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=await this.executor.executeAsync(e,t);return a.length>1?a:a[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,a)=>(t[a]=[e[a]],t),{})}dispose(){this.executor.dispose()}}e.GraphModel=re,e.deregisterOp=function(e){delete s[e]},e.loadGraphModel=async function(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e+="model.json?tfjs-format=file");const a=new re(e,t);return await a.load(),a},e.registerOp=function(e,t){const a={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};s[e]=a},e.version_converter="2.3.0",Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-converter.es2017.min.js.map
